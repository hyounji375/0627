setTimeout(콜백함수, 밀리초. 1000=1초) : 넘겨준 함수를 해당 밀리초만큼 흐른 뒤 호출
clearTimeout(설정된 타임아웃 객체) : setTimeout에서 설정된 것을 취소

setInterval(콜백함수, 밀리초) : 넘겨준 함수를 해당 밀리초마다 흐른 뒤 호출
clearInterval(설정된 인터벌 객체) : setInterval에서 설정된 것을 취소

콜백 함수(callback function) : 매개변수로 함수를 전달받아서 함수 내부에서 그 함수를 실행하는 경우.

ex)
const print = ( ) => {
    console.log("print")
}

setTimeout(print, 3000) 여기서 print는 함수
===
setTimeout(()=>{
    console.log("print")
}, 3000)
-----------------------------------------------------------------------------------------
callback 지옥

    : JS는 비동기를 마주하는 상황이 빈번하게 일어남.

    동기적인 흐름   : 너는 나랑 동기니까 같이 할 일 하자.
                      동기는 요청을 보낸 후 결과물을 받아야 다음 동작이 이루어지는 방식.

    비동기적인 흐름 : 너는 나랑 동기가 아니니까 넌 네 할 일 해.
                      효율성을 위해 비동기는 요청을 보낸 후 결과를 받지 않아도 다음 동작이
                      이루어지는 방식.

    ex) 비동기 통신 중에서도 데이터를 받아오기 전에 실행하면 안 되는 코드가 있을 때
        비동기를 동기적인 흐름으로 만들어 줄 필요가 있다.

        블로그를 만들었다.
        게시글 번호, 댓글 내용을 백엔드 서버로 보내면 백엔드 서버는 해당 게시글 번호를 찾아서
        그 게시글의 정보를 데이터베이스(데이터저장소)에서 찾아낸다.(비동기)
        그리고 해당 게시글 정보에 맞는 댓글에 데이터를 추가.
        이 경우 게시글을 찾기도 전에 댓글 데이터를 추가하면 에러가 난다.
        그래서 비동기를 동기적인 흐름으로 만들어서 게시글을 먼저 찾고 그 후에 댓글 추가하도록 해준다.

    이러한 비동기의 동기적 흐름 처리를 위해 콜백함수를 많이 사용하는데
    콜백함수가 중첩되어 함수의 길이가 길어지고 가독성이 떨어지며 코드가 난잡해 보이는 현상을
    콜백지옥 현상이라고 한다.

    콜백지옥 해결 방안

    1. 기명함수.
    하지만 기명함수로도 한계가 있다.
    그래서 나온 게 promise, async/await => 비동기를 동기적으로 처리하기 위해 사용

-------------ES6이후 나옴
promise
    : 비동기 통신 상황일 때 악명 높은 콜백지옥을 탈출했다는 점에서 높은 평가를 받음.
      대기 이행 실패 상태가 존재하며 각 pending, resolve, reject라고 칭함.

      promise를 선언하면 대기 상태에서 실행은 되어 있지만 나중에 어떠한 조건을 만족했을 때 결과값을 받는 객체.
      성공과 실패의 결과값에 따라 다른 실행문 실행해 다른 값을 리턴함.
      resolve를 실행하면 성공 -> then
      reject를 실행하면 실패로 간주 -> catch

async, await
    : promise의 then catch의 반복으로 인해 코드가 길어지는 현상과 
      pending(대기) 상태가 지속되는 현상을 해결하기 위해 등장.
      함수형일 때만 사용 가능함.

